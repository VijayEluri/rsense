Title: RSense Manual
Numbering: yes
CSS: style.css

RSense Manual
=============

[Index](index.txt)

* * *

{toc}

* * *

Introduction
------------

### What is RSense? ###

RSense is a development tools for [Ruby][], which is written in Java. Following [UNIX philosophy][], RSense can be used from anywhere easily. Generally, it is used from editors such like Emacs, Vim, etc. We are struggling to keep a transparency for hackers to learn, extend, and fix easily.

### Features ###

Available main features are:

* Code completion
* Type inspection

In the future, the following features will be also available:

* Static code checking
* Definition jump
* Caller jump
* Refactoring

Installation
------------

### Requirements ###

* Ruby 1.8.x
* JDK 1.5 or later
* Editors

  * Emacs
  * Vim

### Build instructions ###

You can compile RSense with `ant` command.

    % ant

After that, you may see `rsense.jar` in `lib` directory, which is a main compnent of RSense.

Usage
-----

There are two frontends in RSense. The first one is called *primitive frontend* which means only one process can run once a command. The second one is called *wrapper frontend* which means you don't have to care about processes. In other words, in wrapper frontend, you can execute a command regardless server/client model and initialization time. Wrapper frontend would be used in general.

### Primitive frontend ###

A component of primitive frontend is `lib/rsense.jar`. So if you want to use primitive frontend, you have to execute `java` command like:

    % java -cp lib/jruby.jar:lib/antlr-runtime-3.2.jar:lib/rsense.jar org.cx4a.rsense.Main command option...

No need to say, you have to specify a correct classpath in Java. Do you think it's boring? Me too. Anyway, in primitive frontend, you can use following commads and options.

#### `code-completion` command #### {#code_completion_command}

This command collects completions at a specified file location. Specify file name to analyze by `--file=` option and `--location=` option. `--location=` option can be one of:

* a offset number from top of file (0 based)
* line:col format (1 based)
* location mark in string

For example, `--location=123` means completions will be collected at an offset 123 from top of file. `--location=10:8` means completions will be collected at line number 10 and column 8. `--location=_|_` means completions will be collected where `_|_` appears. If `--location=` option is omitted, `--location=_|_` will be used instead.

An unit of offset number and column number is not byte based but character based. If a source code contains non-ascii characters, you may have to specify an encoding by `--encoding=` option. An encoding string must follow [Java Supported Encodings][].

**Example:**

Classpath option is omitted.

    % cat test1.rb
    1
    % java -cp ... org.cx4a.rsense.Main code-completion --file=test1.rb --location=1
    completion: succ
    ...
    % java -cp ... org.cx4a.rsense.Main code-completion --file=test1.rb --location=1:1
    completion: succ
    ...
    % cat test2.rb
    1_|_
    % java -cp ... org.cx4a.rsense.Main code-completion --file=test1.rb --location=_|_
    completion: succ
    ...

#### `type-inference` command #### {#type_inference_command}

Same to [`code-completion` command](#code_completion_command) except this command collects types of expressions. All of options of code-completion commands can be also used in this command.

**Example:**

    % cat test1.rb
    1
    % java -cp ... org.cx4a.rsense.Main type-inference --file=test1.rb --location=1
    type: Fixnum
    % java -cp ... org.cx4a.rsense.Main type-inference --file=test1.rb --location=1:1
    type: Fixnum
    % cat test2.rb
    1_|_
    % java -cp ... org.cx4a.rsense.Main type-inference --file=test1.rb --location=_|_
    type: Fixnum

#### `load` command #### {#load_command}

Load a specified file without any outputs.

**Example:**

    % java -cp ... org.cx4a.rsense.Main load --file=test1.rb

#### `script` command #### {#script_command}

This command is useful for processing a series of commands again and again. If no script files are given, this command reads commands from standard input. An end of each command is detected by mark specified by `--end-mark=` option. If `--end-mark=` option is not given, `--end-mark=EOF` will be used instead.

Some extra commands are allowed in script mode. `exit` or `quit` commands exit RSense immediately. `clear` command clears current environment.

**Example:**

    % java -cp ... org.cx4a.rsense.Main script
    > type-inference
    1_|_
    EOF
    type: Fixnum
    > code-completion
    1_|_
    EOF
    completion: succ
    ...
    ^D
    % cat test.rsense
    type-inference --test=Foo --should-be=Fixnum
    1_|_
    EOF

    type-inference --test=Bar --should-be=String
    'Hello'_|_
    EOF
    % java -cp ... org.cx4a.rsense.Main script test.rsense
    Foo... [OK]
    Bar... [OK]
    test: count=2, success=2, failure=0

#### `help` command #### {#help_command}

Show usage.

#### `version` command #### {#version_command}

Show version of RSense.

#### `--rsense-home` option #### {#rsense_home_option}

Specify RSense home directory. You don't need to specify this option maybe.

#### `--debug` option #### {#debug_option}

You can see debug messages by specifying this option.

#### `--log=` option #### {#log_option}

You can keep log messages into a file by specifying this option.

#### `--format=` option #### {#format_option}

Specifying this option, a command output will be formatted in the specified rule. Available format are `plain` and `emacs`. Default is `plain`.

#### `--encoding=` option #### {#encoding_option}

Specify a file encoding. An encoding string must follow [Java Supported Encodings][]. If this option is omitted, `--encoding=UTF-8` will be used instead.

### Wrapper frontend ###

`bin/rsense` is a wrapper frontend that hides a complex of server/client model. You can use it like `rsense.jar` without initialization time. `bin/rsense` automatically execute a primitive frontend as a background daemon, and starts communication with it.

Available commands and options are mostly same to primitive frontend's. See example.

**Example:**

    % bin/rsense version
    RSense 0.0.1
    % cat test1.rb
    def f() 1 end
    % bin/rsense type-inference --file=test1.rb # define f()
    % cat test2.rb
    f_|_
    % bin/rsense type-inference --file=test2.rb # use f()
    type: Fixnum

Ruby Reference Manual
---------------------

This section describe how to install and use Ruby Reference Manual (refm in abbreviation) from RSense.

### Installation ### {#refm_installation}

Go to <http://www.ruby-lang.org/ja/man/archive/> and download a latest snapshot of refm. Then extract files and rename the directory to `~/src/rurema`, for example.

After installation, if you use Emacs, you need to change `rsense-rurema-home` variable to that directory.

**Example:**

    % cd ~/tmp
    % wget http://www.ruby-lang.org/ja/man/archive/snapshot/ruby-refm-1.9.1-dynamic-snapshot.tar.bz2
    % tar xjf ruby-refm-1.9.1-dynamic-snapshot.tar.bz2
    % mv ruby-refm-1.9.1-dynamic-snapshot ~/src/rurema

### Usage ### {#refm_usage}

In Emacs, you can lookup a reference automatically by completing with auto-complete.

[Ruby]: http://www.ruby-lang.org/ "Ruby Programming Language"
[UNIX philosophy]: http://en.wikipedia.org/wiki/Unix_philosophy
[Java Supported Encodings]: http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html
