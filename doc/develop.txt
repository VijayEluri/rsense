RSense development guide
========================

[Index](index.txt)

Compilation
-----------

You can compile RSense with `make` command.

    % make rsense

After compilation, `lib/rsense.jar` will appear which is a main component of RSense.

In addition, you can run code-completion, type-inference and test scripts via Makefile.

    % make run-code-completion FILE=test.rb LOCATION=123
    % make run-type-inference FILE=test.rb LOCATION=123
    % make run-test

See also [usage](usage.txt) and [testing](test.txt).

Frontend
--------

RSense provides only a frontend which can be used from a terminal. It means there is no way to embed RSense into other frontends (e.g. Editors, IDE). So how we can use it from other frontends? Let us explain.

RSense has a CLI (command line interface) frontend only. Try type inference from a terminal

    % cat test.rb
    1_|_
    % bin/rsense --file=test.rb
    type: Fixnum

`bin/rsense` is a pseudo frontend script which provides us a way to operate RSense transparency in server/client model. When `bin/rsense` is executed, `bin/rsense` tries to execute a daemon server if it doesn't live by forking and executing a real frontend. In a time after forking, it will create an unix domain socket to communicates with a frontend. After executing the daemon, `bin/rsense tries to open the unix domain socket and sends a given command from a terminal.

Considering a command `bin/rsense --file=test.rb`, first of all, `bin/rsense` executes a daemon server by

    % java -cp ... org.cx4a.rsense.Main script ...

In a script mode, it reads a command from standard input and executes as it is a command from a terminal. For example,

    % java -cp ... org.cx4a.rsense.Main some-command --some-option1=foo --some-option2=foo

is equivalent to

    % java -cp ... org.cx4a.rsense.Main script
    some-command --some-option1=foo --some-option2=foo
    ^D

A main difference of these ways is that in a script mode you can execute a series of command. It enables us to save initialization time and do continuous processing. Actually, it is used as a test script. See also [testing](test.txt).

After executing the server, as we said, `bin/rsense` sends a command from a terminal to the server. So we can operate RSense transparency as it seems like a single command.

Using from other frontends is very easy. All of they have to do is just a execution `bin/rsense` with arbitrary command and options. For example, a type inspection can be implemented in emacs like

    (message "%s" (shell-command-to-string (format "bin/rsense type-inference --file=%s --location=%s" (buffer-file-name) (1- (point)))))

All complex things will be done automatically.

See [usage](usage.txt) for more detail.

Type inference algorithm
------------------------

RSense uses a type inference algorithm called *CPA* (Cartesian Product Algorithm) which is developed by Ole Agensen. With some restriction of CPA such like data-polymorphism, RSense uses a modified CPA indeed. We think CPA is very simple to implement and a best way to accomplish what RSense tries to privde.

Type annotation
---------------

CPA doesn't support data-polymorphism. It is a serious problem for Ruby. Think the following code.

    a = []
    a << 1
    b = []
    b << 'Hello'
    b[0]    # What type of mine?

In a system without data-polymorphism, the algorithm infers it has `Fixnum` and `String`. Why? Because, `Array`'s elements is thought of as a kind of instance variable. So a type of elements will be shared.

In our system, to avoid such the grave, we adopt type annotation. *Type annotation* enables us to make a type data-polymorphic and ad-hoc parameter polymorphic. It is inspired from Diamondback Ruby's, but they are completely different.

See [type annotation](annot.txt) in detail.

Partial update
--------------

A most important thing for RSense is speed. If users have to wait 10 senconds to do type inspection, it is finally a garbage. So, we have to keep RSense faster as much as possible. One of ways to make RSense faster is a technique called *partial update*. When RSense is requested to do code-completion or type-inference, RSense checks for AST cache. If there is AST cache, RSense analyzes an edit delta and apply updating to modified portion of the source code.

Source tree
-----------

    rsense/
    |- bin/                                  - Pseudo frontend and utilities
    |- build_lib/                            - Libraries needed to build RSense
    |- doc/                                  - Documentation
    |- etc/                                  - Other frontends and etc files
    |- lib/                                  - Libraries needed to run
    |- src/                                  - Real frontend source code
    |  |- org/cx4a/rsense/
    |              |- parser/                - Type annotation parser
    |              |- ruby/                  - Pseudo ruby runtime
    |              |- typing/                - Type inference
    |              |- util/
    |- stubs/                                - Type annotation stubs
    |- test/                                 - Test cases and test scripts

Related work and keywords
-------------------------

* CPA

  Constraint based type inference algorithm.

* DCPA

  Data-polymorphic CPA.

* [DDP](http://www.lexspoon.org/ti/)

  Demand-drived type-inference algorithm.

* [Ecstatic](http://zianet.dk/blog/2007/06/19/my-thesis-type-inference-for-ruby/)

  Static code checking tool for Ruby based on CPA.
  
* Starkiller

  Static code checking tool for Python based on CPA.

* [Diamondback Ruby](http://www.cs.umd.edu/projects/PL/druby/)

  Static code checking tool for Ruby based on constraint-based algorithm.
